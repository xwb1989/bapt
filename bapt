#!/usr/bin/python
#File: bapt
#Author: Wenbin Xiao
#Date: 2014/10/07

#========================================  imports  ====================================
import sys
import zipfile
import tarfile
import os
import argparse
from cStringIO import StringIO


#========================================  Config ======================================
SUPPORT_LANG = ["java", "c", "py"]
#========================================  utils  ======================================
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'

    def disable(self):
        self.HEADER = ''
        self.OKBLUE = ''
        self.OKGREEN = ''
        self.WARNING = ''
        self.FAIL = ''
        self.ENDC = ''

def INFO(string):
    print(bcolors.HEADER + str(string) + bcolors.ENDC)

def OK(string):
    print(bcolors.OKGREEN + str(string) + bcolors.ENDC)

def WARN(string):
    print(bcolors.WARNING + str(string) + bcolors.ENDC)

def ERRO(string):
    print(bcolors.FAIL + str(string) + bcolors.ENDC)
    sys.exit(1)

def welcome():
    print("Welcome to (B)randeis (A)nti-(P)lagiarism (T)ool.")
    print("This tool is using MOSS from Stanford University as plagiarism detection engine")
    print("and provides automatical files pre-process and configurations such that submitting")
    print("the programming assignments of whole class(or with previous classes) can be done")
    print("without much manual effort.\n")
    print("If you have any question about this tool, please email the author:")
    print("\t\tWenbin Xiao(wenbinx@brandeis.edu)")

#identify archive by extension
def is_archive(f):
    return f.endswith(("tar", "zip", "tgz", "tar.gz"))

#identify zip by extension
def is_zip(f):
    return f.endswith("zip")

#identify zip by extension
def is_tar(f):
    return f.endswith(("tgz", "tar", "tar.gz"))

def match(s1, l1):
    for s2 in l1:
        if s2 in s1:
            return True
    return False
    
#extract files in in-memory archive data
def extract_data(f_name, f_data, dest, file_type, ignore_list):
    if is_zip(f_name):
        #crate ZipFile by passing a file-like object
        extract_zip(zipfile.ZipFile(f_data), dest, file_type, ignore_list)
    elif is_tar(f_name):
        #create TarFile by passing fileobj
        extract_tar(tarfile.open(fileobj=f_data), dest, file_type, ignore_list)
    else:
        WARN("unable to identify %s" %(f_name))

#recursively extract files in tar file
def extract_tar(tar_file, dest, file_type, ignore_list):
    for f_name in tar_file.getnames():
        if match(f_name, ignore_list):
            continue
        elif f_name.endswith(tuple(file_type)):
            #tar_file.extract(f_name, path=dest)
            INFO(f_name)
        elif is_archive(f_name):
            WARN(f_name)
            f_data = tar_file.extractfile(f_name)
            extract_data(f_name, f_data, dest, file_type, ignore_list)

#recursively extract files in zip file
def extract_zip(zip_file, dest, file_type, ignore_list):
    for f_name in zip_file.namelist():
        if match(f_name, ignore_list):
            continue
        elif f_name.endswith(tuple(file_type)):
            INFO(f_name)
        elif is_archive(f_name):
            WARN(f_name)
            #result of read() is unseekable, we need to wrap it with StringIO
            f_data = StringIO(zip_file.read(f_name)) 
            extract_data(f_name, f_data, dest, file_type, ignore_list)

def extract_all(file_path, dest_path, file_type, ignore_list):
    if is_tar(file_path):
        tar_file = tarfile.open(file_path)
        extract_tar(tar_file, dest_path, file_type, ignore_list)
    elif is_zip(file_path):
        zip_file = zipfile.ZipFile(file_path)
        extract_zip(zip_file, dest_path, file_type, ignore_list)
    else:
        WARN("Unable to identify the type of file: %s" % ( file_path ))
    return True
    
#Validate the directories given by command line arguments
class ValidDir(argparse.Action):
    def __call__(self, parser, namespace, values, option_strings=None):
        failed = False
        if type(values) == list:
            for p in values:
                if not os.path.isdir(p):
                    raise Exception("Invalid argument: %s" %(p))
        else:
            if not os.path.isdir(values):
                raise Exception("Invalid argument: %s" %(values))
        setattr(namespace, self.dest, values)
        

#====================================== Main ====================================
if __name__ == "__main__":

    if len(sys.argv) < 4:
        welcome()
    INFO("====================================  Argument Parsing  =================================")
    #create argument parser
    parser = argparse.ArgumentParser(description="Parsing arguments for BAPT")
    #add arguments
    parser.add_argument("-l", required=True, 
            nargs=1, dest="lang", 
            help="the language of the submission files")
    parser.add_argument("-b", required=False, 
            nargs='?', dest="base_files", action=ValidDir,
            help="the directory of base files")
    parser.add_argument("-d", required=True, 
            nargs='+', dest="directories", action=ValidDir,
            help="directories of submission files")
    try:
        args = parser.parse_args()
    except Exception as e:
        WARN(" ".join(e.args))
        ERRO("Invalid command: %s" %(" ".join(sys.argv)))
    INFO("====================================  Argument Parsing done  ============================")

    for directory in args.directories:
        for archive_file in [f for f in os.listdir(directory) if is_archive(f)]:
            dest = os.path.join(directory, archive_file[:archive_file.find(".")])
            file_path = os.path.join(directory, archive_file)
            if not os.path.isdir(dest):
                extract_all(file_path, dest, args.lang, ["__MACOSX"])
            
            

         

    sys.exit(0)



    min_argc = 4



    


    #MOSS arguments
    directories = ""
    lang = ""
    base_files = ""
    i = 1
    try:
        while i < len(sys.argv):
            arg = sys.argv[i]
            if arg == "-l":
                lang = "-l"
                i += 1
                tmp = sys.argv[i]
                if tmp in SUPPORT_LANG:
                    lang = lang + " " + tmp
                else:
                    raise Exception("Invalid language: %s" %(tmp))
            elif arg == "-b":
                base_files = "-b"
                i += 1
                tmp = sys.argv[i]
                if os.path.isdir(tmp):
                    base_files = base_files + " " + tmp
                else:
                    raise Exception("Invalid base file directory: %s" %(tmp))
            elif arg == "-d":
                directories = "-d"
                i += 1
                while i < len(sys.argv):
                    tmp = sys.argv[i]
                    if os.path.isdir(tmp):
                        directories = directories + " " + tmp
                    else:
                        raise Exception("Invalid directory: %s" %(tmp))
                    i += 1
            else:
                raise Exception("Invalid arguments: %s" %(arg))
            i += 1
        if lang == "" or directories == "":
            raise Exception("Invalid -l or -d")
    except Exception as e:
        WARN(" ".join(e.args))
        ERRO("Invalid command: %s" % (" ".join(sys.argv)))

    OK("moss %s %s %s" %(lang, base_files, directories))





















